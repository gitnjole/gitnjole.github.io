---
layout: post
title: Production-ready fizzbuzz (Part 1)
date: 2024-03-03
description: A journey through the 9 circles of design patterns
tags: php design pattern
categories: fizzbuzz
related_posts: false
---

# Embarking on the Production Journey

Imagine a problem set before you:

Given an array `array`, your task is to return a string array called `answer` (1-indexed) where:

- `answer[i]` is "FizzBuzz" if i is divisible by both 3 and 5.
- `answer[i]` is "Fizz" if i is divisible by 3.
- `answer[i]` is "Buzz" if i is divisible by 5.
- `answer[i]` is the string representation of i if none of the above conditions are met.

Consider these examples:

Example 1:
```bash
Input: $array = range(1,3)
Output: ["1","2","Fizz"]
```

Example 2:
```bash
Input: $array = range(1,5)
Output: ["1","2","Fizz","4","Buzz"]
```

Example 3:
```bash
Input: $array = range(1,15)
Output: ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
```

It's a fundamental programming challenge, testing basic division and loop comprehension. My mission? To craft a production-ready, highly scalable, and pattern-constrained FizzBuzz program using PHP.

Throughout this journey, we'll progressively enhance the solution, layering in increasingly sophisticated design patterns until we birth a truly refined, functional codebase. One poised for global deployment, destined to be embraced by billions as the definitive FizzBuzz solution.

In Part 1 of this series, our focus lies on crafting a **simple**, functional FizzBuzz implementation.

# Unveiling the Simple Solution

Let's revisit the problem statement: we're tasked with processing an integer representing the range of numbers to be assessed. For each number, we check if it's divisible by 3 or 5, appending "Fizz" or "Buzz" accordingly. If divisible by both, we output "FizzBuzz". Otherwise, we pass the number unchanged.

Here's my implementation:

```php
$nums = range(1,3);

$result = array_map(function ($num) {
    $output = '';

    if ($num % 3 == 0) $output .= 'Fizz';
    if ($num % 5 == 0) $output .= 'Buzz';

    return $output ?: $num;
}, $nums);

print_r($result);
```

This code yields the following output:
```bash
Array
(
    [0] => 1
    [1] => 2
    [2] => Fizz
)
```

So far, so good. The code functions as intended, boasting optimal efficiency with a big O notation of O(n). Yet, our leadership craves more: they seek complexity, _scalability_, and **modernity**.

And that's precisely what you'll find in this blog. An evolved FizzBuzz apparatus. In the upcoming chapters, we'll transform our solution into an object-oriented paradigm, integrating our first design pattern: the **Flyweight**.

Stay tuned!